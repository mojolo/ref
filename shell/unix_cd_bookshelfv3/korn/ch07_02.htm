<html><head><title>String I/O (Learning the Korn Shell, 2nd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Arnold Robbins and Bill Rosenblatt" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0-596-00195-9" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Learning the Korn Shell, 2nd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Book Home" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Book Title" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch07_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch07_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">7.2. String I/O</h2>

<p>
<a name="korn2-IDXTERM-1429" />

Now we'll zoom back in to the string I/O level and examine
the <em class="emphasis">print</em>, <em class="emphasis">printf</em>,
and <em class="emphasis">read</em> statements, which give the shell
I/O capabilities that are more analogous to those of conventional
programming languages.
</p>

<a name="korn2-CHP-7-SECT-2.1" /><div class="sect2">
<h3 class="sect2">7.2.1. print</h3>

<p>
<a name="korn2-IDXTERM-1430" />
As we've seen countless times in this book, <em class="emphasis">print</em> simply
prints its arguments to standard output.
You should use it
instead of the <em class="emphasis">echo</em> command, whose functionality differs from
system to system.<a href="#FOOTNOTE-96">[96]</a>
(The Korn shell's built-in version of <em class="emphasis">echo</em> emulates whatever
the system's standard version of <em class="emphasis">echo</em> does.)
Now we'll explore the <em class="emphasis">print</em> command in greater detail.
</p><blockquote class="footnote">
<a name="FOOTNOTE-96" /><p> [96]
<a name="IXT-7-287898" />

Specifically, there is a difference between System V and BSD
versions.
The latter accepts options similar to those of
<em class="emphasis">print</em>, while the former accepts C language-style escape
sequences.
</p>
</blockquote>

<a name="korn2-CHP-7-SECT-2.1.1" /><div class="sect3">
<h3 class="sect3">7.2.1.1. print escape sequences</h3>

<p>
<a name="korn2-IDXTERM-1432" />
<em class="emphasis">print</em> accepts a number of options, as well as several
<em class="emphasis">escape sequences</em> that start with a backslash.
(You must use a double backslash if you don't surround
the string that contains them with quotes; otherwise, the
shell itself "steals" a backslash before
passing the arguments to <em class="emphasis">print</em>.)
These are similar to the escape sequences
recognized by <em class="emphasis">echo</em> and the C language; they are listed
in <a href="ch07_02.htm#korn2-CHP-7-TABLE-2">Table 7-2</a>.
</p>

<p>
These sequences exhibit fairly predictable behavior, except for <tt class="literal">\f</tt>.
On some displays, it causes a screen clear, while on others
it causes a line feed. It ejects the page on most printers.
<tt class="literal">\v</tt> is somewhat obsolete; it usually causes a line feed.
</p>

<a name="korn2-CHP-7-TABLE-2" /><h4 class="objtitle">Table 7-2. print escape sequences</h4><table border="1" cellpadding="3">




<tr>
<th>Sequence</th>
<th>Character printed</th>
</tr>




<tr>
<td><tt class="literal">\a</tt></td>
<td>ALERT or CTRL-G</td>
</tr>

<tr>
<td><tt class="literal">\b</tt></td>
<td>BACKSPACE or CTRL-H</td>
</tr>

<tr>
<td><tt class="literal">\c</tt></td>
<td><p>
Omit final newline and discontinue processing the string
</p></td>
</tr>

<tr>
<td><tt class="literal">\E</tt></td>
<td>ESCAPE or CTRL-[</td>
</tr>

<tr>
<td><tt class="literal">\f</tt></td>
<td>FORMFEED or CTRL-L</td>
</tr>

<tr>
<td><tt class="literal">\n</tt></td>
<td>newline (not at end of command) or CTRL-J</td>
</tr>

<tr>
<td><tt class="literal">\r</tt></td>
<td>ENTER (RETURN) or CTRL-M</td>
</tr>

<tr>
<td><tt class="literal">\t</tt></td>
<td>TAB or CTRL-I</td>
</tr>

<tr>
<td><tt class="literal">\v</tt></td>
<td>VERTICAL TAB or CTRL-K</td>
</tr>

<tr>
<td><tt class="literal">\0</tt><em class="replaceable"><tt>n</tt></em></td>
<td><p>
ASCII character with octal (base-8) value <em class="emphasis">n</em>,
where <em class="emphasis">n</em> is 1 to 3 digits. Unlike C, C++, and
many other languages, the initial <tt class="literal">0</tt> is required.
</p></td>
</tr>

<tr>
<td><tt class="literal">\\</tt></td>
<td>Single backslash</td>
</tr>


</table><p>

<p>
The <tt class="literal">\0</tt><em class="replaceable"><tt>n</tt></em> sequence is even more
device-dependent and can
be used for complex I/O, such as cursor control and special
graphics characters.
<a name="IXTR3-303" />

</p>
</div>


<a name="korn2-CHP-7-SECT-2.1.2" /><div class="sect3">
<h3 class="sect3">7.2.1.2. Options to print</h3>

<p>
<a name="korn2-IDXTERM-1434" />
<em class="emphasis">print</em> also accepts a few dash options; we've already seen
<em class="emphasis">-n</em> for omitting the final newline. The options
are listed in <a href="ch07_02.htm#korn2-CHP-7-TABLE-3">Table 7-3</a>.


<a name="IXT-7-287899" />
<a name="IXT-7-287900" />
<a name="IXT-7-287901" />
<a name="IXT-7-287902" />
<a name="IXT-7-287903" />
<a name="IXT-7-287904" />


</p>

<a name="korn2-CHP-7-TABLE-3" /><h4 class="objtitle">Table 7-3. print options</h4><table border="1" cellpadding="3">



<tr>
<th>Option</th>
<th>Function</th>
</tr>




<tr>
<td><tt class="literal">-e</tt></td>
<td><p>
Process escape sequences in the arguments (this is the default).
</p></td>
</tr>

<tr>
<td><tt class="literal">-f</tt> <em class="replaceable"><tt>format</tt></em></td>
<td><p>
Print as if via <em class="emphasis">printf</em> with the given <em class="emphasis">format</em>
(see the next section).
</p></td>
</tr>

<tr>
<td><tt class="literal">-n</tt></td>
<td><p>
Omit the final newline (same as the <tt class="literal">\c</tt> escape sequence).
</p></td>
</tr>

<tr>
<td><tt class="literal">-p</tt></td>
<td><p>
Print on pipe to coroutine; see <a href="ch08_01.htm">Chapter 8</a>.
</p></td>
</tr>

<tr>
<td><tt class="literal">-r</tt></td>
<td><p>
Raw; ignore the escape sequences listed above.
</p></td>
</tr>

<tr>
<td><tt class="literal">-R</tt></td>
<td><p>
Like <em class="emphasis">-r</em>, but furthermore ignore any other options except <em class="emphasis">-n</em>.
</p></td>
</tr>

<tr>
<td><tt class="literal">-s</tt></td>
<td><p>
Print to command history file (see <a href="ch02_01.htm">Chapter 2</a>).
</p></td>
</tr>

<tr>
<td><tt class="literal">-u</tt><em class="replaceable"><tt>n</tt></em></td>
<td><p>
Print to file descriptor <em class="emphasis">n</em>.
</p></td>
</tr>


</table><p>

<p>
Notice that some of these are redundant:
<tt class="literal">print -n</tt> is the same as <em class="emphasis">print</em> with
<tt class="literal">\c</tt> at the end of a line;
<tt class="literal">print -u</tt><em class="replaceable"><tt>n</tt></em> ... is
equivalent to <tt class="literal">print</tt> ... <tt class="literal">&gt;&amp;</tt><em class="replaceable"><tt>n</tt></em>
(though the former is slightly more efficient).
</p>

<p>

<a name="IXT-7-287905" />

<a name="korn2-IDXTERM-1442" />

However, <tt class="literal">print -s</tt> is <em class="emphasis">not</em>
the same as <tt class="literal">print</tt> ... <tt class="literal">&gt;&gt; $HISTFILE</tt>.
The latter command renders the vi and emacs editing
modes temporarily inoperable;
you must use <tt class="literal">print -s</tt> if you
want to print to your history file.
</p>

<p>
Printing to your history file is useful if you want to edit something
that the shell expands when it processes a command line, for example,
a complex environment variable such as <tt class="literal">PATH</tt>.

If you enter the command <tt class="literal">print -s PATH=$PATH</tt>,
hit ENTER, and then press
CTRL-P in emacs-mode (or ESC k in vi-mode), you will see something
like this:
</p>

<p>
<blockquote><pre class="code">
$ <span class="emphasis-reverse">P</span><tt class="userinput"><b>ATH=/bin:/usr/bin:/etc:/usr/ucb:/usr/local/bin:/home/billr/bin</b></tt>
</pre></blockquote>
</p>

<p>
That is, the shell expands the variable (and anything
else, like command substitutions, wildcards, etc.) before it writes
the line to the history file.
Your cursor will be at the end of the line (or at the beginning of the
line in vi-mode), and you can edit your <tt class="literal">PATH</tt> without having
to type in the whole thing again.
<a name="IXTR3-304" />
<a name="IXTR3-305" />
<a name="IXTR3-306" />
<a name="IXTR3-307" />

</p>
</div>
</div>

<a name="korn2-CHP-7-SECT-2.2" /><div class="sect2">
<h3 class="sect2">7.2.2. printf</h3>

<p>
If you need to produce formatted reports,
the shell's <em class="emphasis">print</em> command can be combined with
formatting attributes for variables to produce output data that lines
up reasonably.  But you can only do so much with these facilities.
</p>

<p>
The C language's <em class="emphasis">printf</em>(3) library routine provides
powerful formatting facilities for total control of output.  It is so useful
that many other Unix-derived programming languages,
such as <em class="emphasis">awk</em> and <em class="emphasis">perl</em>,
support similar or identical facilities.
Primarily because the behavior of <em class="emphasis">echo</em> on different Unix
systems could not be reconciled, and
recognizing <em class="emphasis">printf</em>'s utility, the POSIX shell
standard mandates a <em class="emphasis">printf</em> shell-level command that
provides the same functionality as the <em class="emphasis">printf</em>(3) library
routine.
This section describes how the <em class="emphasis">printf</em> command works
and examines additional capabilities unique to the Korn shell's version of
<em class="emphasis">printf</em>.
</p>

<p>
The <em class="emphasis">printf</em> command can output a simple string
just like the <em class="emphasis">print</em> command.
</p>

<blockquote><pre class="code">
printf "Hello, world\n"
</pre></blockquote>

<p>
The main difference that you will notice at the outset is
that, unlike <em class="emphasis">print</em>, <em class="emphasis">printf</em> does not
automatically supply a newline.  You must specify it 
explicitly as <tt class="literal">\n</tt>.
</p>

<p>
The full syntax of the <em class="emphasis">printf</em> command has two parts: 
</p>

<p>
<blockquote><pre class="code">
printf <em class="replaceable"><tt>format-string</em> [<em class="replaceable">arguments ...</tt></em>]
</pre></blockquote>
</p>

<p>
The first part is a string that describes the format specifications;
this is best supplied as a string constant in quotes.  The second
part is an argument list, such as a list of strings or variable
values, that correspond to the format specifications.  (If there are
more arguments than format specifications, <em class="emphasis">ksh</em>
cycles through the format specifications in the format string, reusing
them in order, until done.)  A format specification is preceded by a
percent sign (<tt class="literal">%</tt>), and the specifier is one of the
characters described shortly.  Two of the main format specifiers are
<tt class="literal">%s</tt> for strings and <tt class="literal">%d</tt> for decimal
integers.
</p>

<p>
The format string combines text to be output literally with specifications
describing how to format subsequent arguments on the <em class="emphasis">printf</em>
command line.
For example:
</p>

<p>
<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "Hello, %s\n" World</b></tt>
Hello, World
</pre></blockquote>
</p>

<p>
Because the <em class="emphasis">printf</em> command is built-in,
you are not limited to absolute numbers:

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "The answer is %d.\n" 12+10+20</b></tt>
The answer is 42.
</pre></blockquote>
</p>

<p>
The allowed specifiers are shown in <a href="ch07_02.htm#korn2-CHP-7-TABLE-4">Table 7-4</a>.
</p>

<a name="korn2-CHP-7-TABLE-4" /><h4 class="objtitle">Table 7-4. Format specifiers used in printf</h4><table border="1" cellpadding="3">



<tr>
<th>Specifier</th>
<th>Description</th>
</tr>



<tr>
<td><tt class="literal">%c</tt></td>
<td><p>
ASCII character (prints first character of corresponding argument)
</p></td>
</tr>

<tr>
<td><tt class="literal">%d</tt></td>
<td>Decimal integer</td>
</tr>

<tr>
<td><tt class="literal">%i</tt></td>
<td>Decimal integer</td>
</tr>

<tr>
<td><tt class="literal">%e</tt></td>
<td><p>
Floating-point format
([-]<em class="emphasis">d</em>.<em class="emphasis">precision</em><tt class="literal">e</tt>[+-]<em class="emphasis">dd</em>)
(see following text for meaning of <em class="emphasis">precision</em>)
</p></td>
</tr>

<tr>
<td><tt class="literal">%E</tt></td>
<td>Floating-point format ([-]<em class="emphasis">d</em>.<em class="emphasis">precision</em><tt class="literal">E</tt>[+-]<em class="emphasis">dd</em>)
</td>
</tr>

<tr>
<td><tt class="literal">%f</tt></td>
<td>Floating-point format ([-]<em class="emphasis">ddd</em>.<em class="emphasis">precision</em>)</td>
</tr>

<tr>
<td><tt class="literal">%g</tt></td>
<td><p>
<tt class="literal">%e</tt> or <tt class="literal">%f</tt> conversion,
whichever is shorter, with trailing zeros removed
</p></td>
</tr>

<tr>
<td><tt class="literal">%G</tt></td>
<td><p>
<tt class="literal">%E</tt> or <tt class="literal">%f</tt> conversion,
whichever is shortest, with trailing zeros removed
</p></td>
</tr>

<tr>
<td><tt class="literal">%o</tt></td>
<td>Unsigned octal value</td>
</tr>

<tr>
<td><tt class="literal">%s</tt></td>
<td>String</td>
</tr>

<tr>
<td><tt class="literal">%u</tt></td>
<td>Unsigned decimal value</td>
</tr>

<tr>
<td><tt class="literal">%x</tt></td>
<td>Unsigned hexadecimal number. Uses <tt class="literal">a</tt>-<tt class="literal">f</tt> for 10 to 15</td>
</tr>

<tr>
<td><tt class="literal">%X</tt></td>
<td>Unsigned hexadecimal number. Uses <tt class="literal">A</tt>-<tt class="literal">F</tt> for 10 to 15</td>
</tr>

<tr>
<td><tt class="literal">%%</tt></td>
<td>Literal %</td>
</tr>

</table><p>

<p>
The <em class="emphasis">printf</em> command can be used to specify the width
and alignment of output fields.  A format expression
can take three optional modifiers following <tt class="literal">%</tt> and preceding the format
specifier:
</p>

<blockquote><pre class="code">
%<em class="replaceable"><tt>flags width</em>.<em class="replaceable">precision format-specifier</tt></em>
</pre></blockquote>

<p>
The <em class="emphasis">width</em> of the output field is a numeric value. 
When you specify a field width, the contents of the field
are right-justified by default.  You must specify a flag of
"-" to get left-justification.
(The rest of the <em class="emphasis">flags</em> are discussed shortly.)
Thus, <tt class="literal">"%-20s"</tt> outputs
a left-justified string in a field 20 characters wide.  If
the string is less than 20 characters, the field is
padded with whitespace to fill.
In the following examples,
a <tt class="literal">|</tt> is output to indicate the actual width of the field.
The first example right-justifies the text: 
</p>

<blockquote><pre class="code">
printf "|%10s|\n" hello
</pre></blockquote>

<p>
It produces:
</p>

<blockquote><pre class="code">
|     hello|
</pre></blockquote>

<p>
The next example left-justifies the text: 
</p>

<blockquote><pre class="code">
printf "|%-10s|\n" hello
</pre></blockquote>

<p>
It produces:
</p>

<blockquote><pre class="code">
|hello     |
</pre></blockquote>

<p>
The <em class="emphasis">precision</em> modifier, used for decimal
or floating-point values, controls the number of digits
that appear in the result.
For string values, it controls the maximum number of characters
from the string that will be printed.
</p>

<p>
You can specify both the <em class="emphasis">width</em> and <em class="emphasis">precision</em> dynamically,
via values in the <i class="command">printf</i> argument list.
You do this by specifying asterisks, instead of literal values.
</p>

<blockquote><pre class="code">
$ <tt class="userinput"><b>myvar=42.123456</b></tt>
$ <tt class="userinput"><b>printf "|%*.*G|\n" 5 6 $myvar</b></tt>
|42.1235|
</pre></blockquote>

<p>
In this example, the width is 5, the precision is 6, and the value
to print comes from the value of <tt class="literal">myvar</tt>.
</p>

<p>
The <em class="emphasis">precision</em> is optional.
Its exact meaning varies by control letter,
as shown in
<a href="ch07_02.htm#korn2-CHP-7-TABLE-5">Table 7-5</a>:
</p>

<a name="korn2-CHP-7-TABLE-5" /><h4 class="objtitle">Table 7-5. Meaning of precision</h4><table border="1" cellpadding="3">


<tr>
<th>Conversion</th>
<th><p>
Precision means
</p></th>
</tr>




<tr>
<td><tt class="literal">%d</tt>, <tt class="literal">%i</tt>, <tt class="literal">%o</tt>, <tt class="literal">%u</tt>, <tt class="literal">%x</tt>, <tt class="literal">%X</tt></td>
<td><p>
The minimum number of digits to print.
When the value has fewer digits, it is padded with leading zeros.
The default precision is 1.
</p></td>
</tr>

<tr>
<td><tt class="literal">%e</tt>, <tt class="literal">%E</tt></td>
<td><p>
The minimum number of digits to print.
When the value has fewer digits, it is padded with zeros after
the decimal point.
The default precision is 10.
A precision of 0 inhibits printing of the decimal point.
</p></td>
</tr>

<tr>
<td><tt class="literal">%f</tt></td>
<td><p>
The number of digits to the right of the decimal point.
</p></td>
</tr>

<tr>
<td><tt class="literal">%g</tt>, <tt class="literal">%G</tt></td>
<td><p>
The maximum number of significant digits.
</p></td>
</tr>

<tr>
<td><tt class="literal">%s</tt></td>
<td><p>
The maximum number of characters to print.
</p></td>
</tr>


</table><p>

<p>
Finally, one or more <em class="emphasis">flags</em> may precede the field width and
the precision.  We've already seen the "-" flag for left-justification.
The rest of the flags are shown in
<a href="ch07_02.htm#korn2-CHP-7-TABLE-6">Table 7-6</a>.
</p>


<a name="korn2-CHP-7-TABLE-6" /><h4 class="objtitle">Table 7-6. Flags for printf</h4><table border="1" cellpadding="3">


<tr>
<th><p>Character</p></th>
<th><p>Description</p></th>
</tr>




<tr>
<td><tt class="literal">-</tt></td>
<td><p>
Left-justify the formatted value within the field.
</p></td>
</tr>

<tr>
<td><em class="emphasis">space</em></td>
<td><p>
Prefix positive values with a space and negative values with a minus.
</p></td>
</tr>

<tr>
<td><tt class="literal">+</tt></td>
<td><p>
Always prefix numeric values with a sign,
even if the value is positive.
</p></td>
</tr>

<tr>
<td><tt class="literal">#</tt></td>
<td><p>
Use an alternate form:
<tt class="literal">%o</tt> has a preceding <tt class="literal">0</tt>;
<tt class="literal">%x</tt> and <tt class="literal">%X</tt> are prefixed with
<tt class="literal">0x</tt> and <tt class="literal">0X</tt>, respectively;
<tt class="literal">%e</tt>, <tt class="literal">%E</tt> and <tt class="literal">%f</tt>
always have a decimal point in the result;
and
<tt class="literal">%g</tt> and <tt class="literal">%G</tt> do not have
trailing zeros removed.
</p></td>
</tr>

<tr>
<td><tt class="literal">0</tt></td>
<td><p>
Pad output with zeros, not spaces.
This only happens when the field width is wider than the converted result.
In the C language,
this flag applies to all output formats, even non-numeric ones.
For <em class="emphasis">ksh</em>, it only applies to the numeric formats.
</p></td>
</tr>


</table><p>

<p>
If <em class="emphasis">printf</em> cannot perform a format conversion, it
returns a non-zero exit status.
</p>

<p>
Similar to <em class="emphasis">print</em>, the built-in <em class="emphasis">printf</em> command
interprets escape sequences within the format string.
However, <em class="emphasis">printf</em> accepts a larger range of escape sequences; they
are the same as for the <tt class="literal">$'</tt>...<tt class="literal">'</tt> string.
These sequences are listed later in <a href="ch07_03.htm#korn2-CHP-7-TABLE-9">Table 7-9</a>.
</p>

<?troff .Nd 10?>

<a name="korn2-CHP-7-SECT-2.2.1" /><div class="sect3">
<h3 class="sect3">7.2.2.1. Additional Korn shell printf specifiers</h3>

<p>
Besides the standard specifiers just described, the Korn shell accepts a number
of additional specifiers. These provide useful features at the expense of
nonportability to other versions of the <em class="emphasis">printf</em> command.
</p>

<dl>

<dt><tt class="literal">%b</tt></dt>
<dd>
When used instead of <tt class="literal">%s</tt>,
expands <em class="emphasis">print</em></tt>-style escape sequences in the argument string.
For example:

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "%s\n" 'hello\nworld'</b></tt>
hello\nworld
$ <tt class="userinput"><b>printf "%b\n" 'hello\nworld'</b></tt>
hello
world
</pre></blockquote>
</p></dd>


<dt><tt class="literal">%H</tt></dt>
<dd>
When used instead of <tt class="literal">%s</tt>, outputs HTML and XML
special characters as their corresponding entity names.  For
example:


<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "%s\n" "Here are real &lt; and &gt; characters"</b></tt>
Here are real &lt; and &gt; characters
$ <tt class="userinput"><b>printf "%H\n" "Here are real &lt; and &gt; characters"</b></tt>
Here&amp;nbsp;are&amp;nbsp;real&amp;nbsp;&amp;lt;&amp;nbsp;and&amp;nbsp;&amp;gt;&amp;nbsp;characters
</pre></blockquote>
</p>

<p>
Interestingly enough, spaces are turned into <tt class="literal">&amp;nbsp;</tt>, the
unbreakable literal HTML and XML space character.
</p></dd>


<dt><tt class="literal">%n</tt></dt>
<dd>
This is borrowed from ISO C.  It places the number of characters written so
far into the given variable.  This is possible since <em class="emphasis">printf</em></tt>
is built-in to the shell.

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "hello, world\n%n" msglen</b></tt>
hello, world
$ <tt class="userinput"><b>print $msglen</b></tt>
13
</pre></blockquote>
</p></dd>


<dt><tt class="literal">%P</tt></dt>
<dd>
When used instead of <tt class="literal">%s</tt>, translates the <em class="emphasis">egrep</em>-style
extended regular expression into an equivalent Korn shell pattern.  For example:

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "%P\n" '(.*\.o|.*\.obj|core)+'</b></tt>
*+(*\.o|*\.obj|core)*
</pre></blockquote>
</p></dd>


<dt><tt class="literal">%q</tt></dt>
<dd>
When used instead of <tt class="literal">%s</tt>, prints the string argument in quotes
in such a way that it could later be reused inside a shell script.
For example:
</p>

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "print %q\n" "a string with ' and \" in it"</b></tt>
print $'a string with \' and " in it'
</pre></blockquote>

<p>
(The <tt class="literal">$'</tt>...<tt class="literal">'</tt>
notation is explained in <a href="ch07_03.htm#korn2-CHP-7-SECT-3.3.1">Section 7.3.3.1</a>,
later in this chapter.)
</p></dd>


<?troff .Nd 10?>

<dt><tt class="literal">%R</tt></dt>
<dd>
Goes the other way from <tt class="literal">%P</tt>, translating patterns into
extended regular expressions.  For example:

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "%R\n" '+(*.o|*.c)'</b></tt>
^(.*\.o|.*\.c)+$
</pre></blockquote>
</p></dd>


<dt><tt class="literal">%(</tt><tt><em class="replaceable">date format</em></tt><tt class="literal">)T</tt></dt>
<dd>
The <em class="emphasis">date format</em></tt> is a date command string similar
to that of <em class="emphasis">date</em></tt>(1).
The argument is a string representing a date and time.  <em class="emphasis">ksh</em></tt> converts
the given date string into the time it represents and then reformats it according
to the <em class="emphasis">date</em></tt>(1) format that you supply.
<em class="emphasis">ksh</em></tt> accepts a wide variety of date and time formats.
For example:

<blockquote><pre class="code">
$ <tt class="userinput"><b>date</b></tt>
Wed Jan 30 15:46:01 IST 2002
$ <tt class="userinput"><b>printf "%(It is now %m/%d/%Y %H:%M:%S)T\n" "$(date)"</b></tt>
It is now 01/30/2002 15:46:07
</pre></blockquote>
</p>

<p>
Unix systems keep time in "seconds since the Epoch."
The Epoch is midnight, January 1, 1970, UTC.  If you have a time value in
this format, you can use it with the <tt class="literal">%T</tt> conversion
specifier by preceding it with a <tt class="literal">#</tt> character, like so:

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf "%(It is now %m/%d/%Y %H:%M:%S)T\n" '#1012398411'</b></tt>
It is now 01/30/2002 15:46:51
</pre></blockquote>
</p></dd>


<dt><tt class="literal">%Z</tt></dt>
<dd>
Print a byte whose value is zero.
</p></dd>


</dl>

<p>
Finally, for the <tt class="literal">%d</tt> format,
after the precision
you may supply an additional period and a number
indicating the output base:

<blockquote><pre class="code">
$ <tt class="userinput"><b>printf '42 is %.3.5d in base 5\n' 42</b></tt>
42 is 132 in base 5
</pre></blockquote>
</p>

</div>
</div>

<a name="korn2-CHP-7-SECT-2.3" /><div class="sect2">
<h3 class="sect2">7.2.3. read</h3>

<p>
<a name="korn2-IDXTERM-1447" />

The other side of the shell's string I/O facilities is
the <em class="emphasis">read</em> command, which
allows you to read values <em class="emphasis">into</em> shell variables.
The basic syntax is:
<a name="IXT-7-287906" />

</p>

<p>
<blockquote><pre class="code">
read <em class="replaceable"><tt>var1 var2 ...</tt></em>
</pre></blockquote>
</p>

<p>
There are a few options, which we cover in <a href="ch07_02.htm#korn2-CHP-7-SECT-2.3.5">Section 7.2.3.5</a>,
later in this chapter.
<a name="IXT-7-287907" />

This statement takes a line from the standard input and
breaks it down into words delimited by any of the characters in the
value of the variable <tt class="literal">IFS</tt> (see <a href="ch04_01.htm">Chapter 4</a>;
these are usually a space, a TAB, and newline).
The words are assigned to variables
<em class="emphasis">var1</em>, <em class="emphasis">var2</em>, etc. For example:
</p>

<p>
<blockquote><pre class="code">
$ <tt class="userinput"><b>read fred bob</b></tt>
<tt class="userinput"><b>dave pete</b></tt>
$ <tt class="userinput"><b>print "$fred"</b></tt>
dave
</pre></blockquote></p><p><blockquote><pre class="code">
$ <tt class="userinput"><b>print "$bob"</b></tt>
pete
</pre></blockquote>
</p>

<p>
If there are more words than variables,
excess words are assigned to the last variable.
<a name="IXT-7-287908" />
If you
omit the variables altogether, the entire line of input is assigned
to the variable <tt class="literal">REPLY</tt>.
</p>

<p>
You may have identified this as the missing ingredient in
the shell programming capabilities we've seen so far.
It resembles input statements in conventional languages, like its
namesake in Pascal. So why did we wait this long to introduce it?
</p>

<p>

Actually, <em class="emphasis">read</em> is sort of an escape hatch from traditional shell
programming philosophy, which dictates that the most important unit
of data to process is a <em class="emphasis">text file</em>, and that Unix
utilities such as <em class="emphasis">cut</em>, <em class="emphasis">grep</em>,
<em class="emphasis">sort</em>,
etc., should be used as building blocks for writing programs.
</p>

<p>
<em class="emphasis">read</em>, on the other hand, implies line-by-line processing.
You could use it to write a shell script that does what a pipeline
of utilities would normally do, but such a script
would inevitably look like:
</p>

<p>
<blockquote><pre class="code">
while (read a line) do
    process the line
    print the processed line
end
</pre></blockquote>
</p>

<p>
This type of script is usually much slower than a pipeline; furthermore, it has the same
form as a program someone might write in C (or some similar language)
that does the same thing much, <em class="emphasis">much</em> faster. In other words,
if you are going to write it in this line-by-line way, there is no point in
writing a shell script.
(The authors have gone for years without writing a script with
<em class="emphasis">read</em> in it.)
</p>

<a name="korn2-CHP-7-SECT-2.3.1" /><div class="sect3">
<h3 class="sect3">7.2.3.1. Reading lines from files</h3>

<p>
Nevertheless, shell scripts with
<em class="emphasis">read</em> are useful for certain kinds of tasks. One is when
you are reading data from a file
small enough so that efficiency isn't a concern
(say a few hundred lines or less),
and it's really necessary to get bits of input into shell variables.
</p>

<p>


One task that we have already seen fits this description: <a href="ch05_03.htm#korn2-CHP-5-SIDEBAR-5">Task 5-4</a>, the script that a system administrator could use to set
a user's <tt class="literal">TERM</tt> environment variable according to which terminal line
he or she is using.

The code in <a href="ch05_01.htm">Chapter 5</a> used a <tt class="literal">case</tt> statement
to select the correct value for <tt class="literal">TERM</tt>.
</p>

<p>

This code would presumably reside in <em class="emphasis">/etc/profile</em>, the
system-wide initialization file that the Korn shell runs before running
a user's <em class="emphasis">.profile</em>. If the terminals on the system change
over time -- as surely they must -- then the code would have to
be changed. It would be better to store the information in a file
and change just the file instead.
</p>

<p>
Assume we put the information in a file whose format is typical
of such Unix "system configuration" files: each line contains
a device name, a TAB, and a <tt class="literal">TERM</tt> value.
If the file, which we'll call
<em class="emphasis">/etc/terms</em>,
contained the same data as the <tt class="literal">case</tt> statement
in <a href="ch05_01.htm">Chapter 5</a>, it would look like this:
</p>

<p>
<blockquote><pre class="code">
console s531
tty01   gl35a
tty03   gl35a
tty04   gl35a
tty07   t2000
tty08   s531
</pre></blockquote>
</p>

<p>
We can use <em class="emphasis">read</em> to get the data from this file, but first we
need to know how to test for the end-of-file condition.

Simple: <em class="emphasis">read</em>'s exit status is 1 (i.e., nonzero) when there is
nothing to read.

This leads to a clean <tt class="literal">while</tt> loop:
</p>

<p>
<blockquote><pre class="code">
TERM=vt99       # assume this as a default
line=$(tty)
while read dev termtype; do
    if [[ $dev == $line ]]; then
        TERM=$termtype
        export TERM
        print "TERM set to $TERM."
        break
    fi
done
</pre></blockquote>
</p>

<p>
The <tt class="literal">while</tt> loop reads each line of the input into the variables
<tt class="literal">dev</tt> and <tt class="literal">termtype</tt>.

In each pass through the loop,
the <tt class="literal">if</tt> looks for a match between <tt class="literal">$dev</tt> and the user's
tty (<tt class="literal">$line</tt>, obtained by command substitution from the <em class="emphasis">tty</em>
command). If a match is found, <tt class="literal">TERM</tt> is set and exported, a message is printed,
and the loop
exits; otherwise <tt class="literal">TERM</tt> remains at the default setting of <tt class="literal">vt99</tt>.
<a name="IXTR3-308" />


</p>

<p>
We're not quite done, though: this code reads from the standard
input, not from <em class="emphasis">/etc/terms</em>! We need to know how to redirect
input to multiple commands. There are
a few ways of doing this.
</p>
</div>


<a name="korn2-CHP-7-SECT-2.3.2" /><div class="sect3">
<h3 class="sect3">7.2.3.2. I/O redirection and multiple commands</h3>

<p>

One way to solve the problem is with
a subshell, as we'll see in the next chapter.
This involves creating a separate process to do the reading.
However, it is usually more efficient to do it in the same process;
the Korn shell gives us three ways of doing this.
</p>

<p>
The first, which we have seen already, is with a function:
</p>

<p>
<blockquote><pre class="code">
function findterm {
    TERM=vt99       # assume this as a default
    line=$(tty)
    while read dev termtype; do
        if [[ $dev == $line ]]; then
            TERM=$termtype
            export TERM
            print "TERM set to $TERM."
            break
        fi
    done
}

findterm &lt; /etc/terms
</pre></blockquote>
</p>

<p>

A function acts like a script in that it has its own set of
standard I/O descriptors, which can be redirected in the line of code that
calls the function.
In other words, you can think of this code as if <em class="emphasis">findterm</em>
were a script and you
typed
<tt class="literal">findterm &lt; /etc/terms</tt> on the
command line. The <em class="emphasis">read</em> statement
takes input from <em class="emphasis">/etc/terms</em>
a line at a time, and the function runs correctly.
</p>

<p>
<a name="IXT-7-287909" />
<a name="IXT-7-287910" />
The second way is by putting the I/O redirector at the end
of the loop, like this:
</p>

<p>
<blockquote><pre class="code">
TERM=vt99       # assume this as a default
line=$(tty)
while read dev termtype; do
    if [[ $dev == $line ]]; then
        TERM=$termtype
        export TERM
        print "TERM set to $TERM."
        break
    fi
done &lt; /etc/terms
</pre></blockquote>
</p>

<p>
<a name="IXT-7-287911" />
<a name="IXT-7-287912" />
<a name="IXT-7-287913" />
<a name="IXT-7-287914" />
<a name="IXT-7-287915" />

You can use this technique with any flow-control construct,
including <tt class="literal">if</tt>...<tt class="literal">fi</tt>,
<tt class="literal">case</tt>...<tt class="literal">esac</tt>,
<tt class="literal">for</tt>...<tt class="literal">done</tt>,
<tt class="literal">select</tt>...<tt class="literal">done</tt>,
and <tt class="literal">until</tt>...<tt class="literal">done</tt>.


This makes sense because these are
all <em class="emphasis">compound statements</em>
that the shell treats as single commands
for these purposes.
This technique works fine -- the <em class="emphasis">read</em> command reads a
line at a time -- as long
as all of the input is done within the compound statement.
</p>

<p>
Putting the I/O redirector at the end is particularly important for
making loops work correctly.  Suppose you place the redirector after
the <em class="emphasis">read</em> command, like so:
</p>

<blockquote><pre class="code">
while read dev termtype &lt; /etc/terms
do
    ...
done
</pre></blockquote>

<p>
In this case, the shell reopens <em class="emphasis">/etc/terms</em> each time
around the loop, reading the first line over and over again.
This effectively creates an infinite loop, something you probably don't want.
</p>

</div>


<a name="korn2-CHP-7-SECT-2.3.3" /><div class="sect3">
<h3 class="sect3">7.2.3.3. Code blocks</h3>

<p>
<a name="korn2-IDXTERM-1459" />
<a name="IXT-7-287916" />

Occasionally, you may want to redirect I/O to or from an arbitrary group
of commands without creating a separate process.  To do that, you need to
use a construct that we haven't seen yet.
If you surround some code with <tt class="literal">{</tt> and <tt class="literal">}</tt>,<a href="#FOOTNOTE-97">[97]</a>
the code
will behave like a function that has no name.
This is another type of compound statement.
<a name="IXT-7-287917" />

In accordance with the equivalent concept in the C
language, we'll call this a <em class="emphasis">block</em> of code.<a href="#FOOTNOTE-98">[98]</a>
</p><blockquote class="footnote">
<a name="FOOTNOTE-97" /><p> [97]
For obscure, historical syntactic reasons, the braces are shell <em class="emphasis">keywords</em>.
In practice, this means that the closing <tt class="literal">}</tt> must be
preceded by either a newline or a semicolon.  Caveat emptor!
</p>
</blockquote><blockquote class="footnote">
<a name="FOOTNOTE-98" /><p> [98]
LISP programmers may prefer to think of this as an
<em class="emphasis">anonymous function</em>
or <em class="emphasis">lambda-function</em>.
</p>
</blockquote>

<p>
What good is a block?
<a name="IXT-7-287918" />
<a name="IXT-7-287919" />

In this case, it means that the code within the curly braces (<tt class="literal">{ }</tt>) will
take standard I/O descriptors just as we described for functions.
This construct is also appropriate for the current example
because the code needs
to be called only once, and the entire script is not really large
enough to merit breaking down into functions. Here is how
we use a block in the example:
</p>

<p>
<blockquote><pre class="code">
{
    TERM=vt99       # assume this as a default
    line=$(tty)
    while read dev termtype; do
        if [[ $dev == $line ]]; then
            TERM=$termtype
            export TERM
            print "TERM set to $TERM."
            break
        fi
    done
} &lt; /etc/terms
</pre></blockquote>
</p>

<p>
To help you understand how this works, think of
the curly braces and the code inside them as if they were one command, i.e.:
</p>

<p>
<blockquote><pre class="code">
{ TERM=vt99; line=$(tty); while ... ; } &lt; /etc/terms
</pre></blockquote>
</p>

<p>
<a name="IXTR3-309" />

</p>

<p>
<a name="IXT-7-287920" />
<a name="IXT-7-287921" />

Configuration files for system administration tasks
like this one are actually fairly common; a prominent example is
<em class="emphasis">/etc/hosts</em>, which lists machines that are accessible
in a TCP/IP network. We can make <em class="emphasis">/etc/terms</em> more like these
standard files by allowing comment lines in
the file that start with <tt class="literal">#</tt>, just as in shell scripts. This way
<em class="emphasis">/etc/terms</em> can look like this:
</p>

<p>
<blockquote><pre class="code">
#
# System Console is a Shande 531s
console s531
#
# Prof. Subramaniam's line has a Givalt GL35a
tty01   gl35a
...
</pre></blockquote>
</p>

<p>
<a name="IXT-7-287922" />

We can handle comment lines in two ways. First, we could modify the <tt class="literal">while</tt>
loop so that it ignores lines beginning with <tt class="literal">#</tt>.
<a name="IXT-7-287923" />
<a name="IXT-7-287924" />
<a name="IXT-7-287925" />

We would
take advantage of the fact that the equality
and inequality operators (<tt class="literal">==</tt> and <tt class="literal">!=</tt>)
under <tt class="literal">[[</tt>...<tt class="literal">]]</tt>
do pattern matching, not just equality testing:
</p>

<p>
<blockquote><pre class="code">
if [[ $dev != \#* &amp;&amp; $dev == $line ]]; then
    ...
</pre></blockquote>
</p>

<p>
The pattern is <tt class="literal">#*</tt>,
which matches any string beginning with <tt class="literal">#</tt>.
We must precede <tt class="literal">#</tt> with a backslash so
that the shell doesn't
treat the rest of the line as a comment.

<a name="IXT-7-287926" />
<a name="IXT-7-287927" />

Also, remember
from <a href="ch05_01.htm">Chapter 5</a> that the <tt class="literal">&amp;&amp;</tt> combines the two
conditions so that <em class="emphasis">both</em> must be true for the entire condition
to be true.
</p>

<p>
<a name="IXT-7-287928" />
<a name="IXT-7-287929" />

This would certainly work, but the usual way to filter out
comment lines is to use a pipeline with <em class="emphasis">grep</em>. We give
<em class="emphasis">grep</em> the regular expression <tt class="literal">^[^#]</tt>, which matches anything except
lines beginning with <tt class="literal">#</tt>.  Then we change the call to the block
so that it reads from the output of the pipeline instead of directly
from the file.<a href="#FOOTNOTE-99">[99]</a>
</p><blockquote class="footnote">
<a name="FOOTNOTE-99" /><p> [99]
Unfortunately, using <em class="emphasis">read</em> with input from a pipe is
often very inefficient, because of issues in the design of the
shell that aren't relevant here.

</p>
</blockquote>

<p>
<blockquote><pre class="code">
grep "^[^#]" /etc/terms | {
    TERM=vt99
    ...
}
</pre></blockquote>
</p>

<p>
We can also use <em class="emphasis">read</em> to improve our solution to <a href="ch06_05.htm#korn2-CHP-6-SIDEBAR-3">Task 6-3</a>,
in which we emulate the multicolumn output of <em class="emphasis">ls</em>.
In the solution in the previous chapter,
we assumed for simplicity that filenames are limited to 14 characters,
and we used 14 as a fixed column width.
We'll improve the solution so that it allows <em class="emphasis">any</em> filename
length (as in modern Unix versions) and uses the length of the
longest filename (plus 2) as the column width.
</p>

<p>
In order to display the list of files in multicolumn format,
we need to read through the output of <em class="emphasis">ls</em> twice.
In the first pass, we find
the longest filename and use that to set the number of columns as
well as their width; the second pass does the actual output.
Here is a block of code for the first pass:
<a name="IXT-7-287930" />
<a name="IXT-7-287931" />

</p>

<p>
<blockquote><pre class="code">
ls "$@" | {
    let width=0
    while read fname; do
        if (( ${#fname} &gt; $width )); then
            let width=${#fname}
        fi
    done
    let "width += 2"
    let numcols="int(${COLUMNS:-80} / $width)"
}
</pre></blockquote>
</p>

<p>
This code looks a bit like an exercise from a first-semester
programming class.
The <tt class="literal">while</tt> loop goes through the input looking for files
with names that are longer than the longest found so far;
if a longer one is found, its length is saved as the new longest length.
</p>

<p>
After the loop finishes, we add 2 to the width to allow for space
between columns. Then we divide the width of the terminal
by the column width to get the number of columns.
As the shell does division in floating-point, the result is passed
to the <em class="emphasis">int</em> function to produce an integer final result.

Recall from <a href="ch03_01.htm">Chapter 3</a> that the built-in variable <tt class="literal">COLUMNS</tt>
often contains the display width; the construct
<tt class="literal">${COLUMNS:-80}</tt>
gives a default of 80 if this variable is not set.
</p>

<p>
The results of the block are the variables <tt class="literal">width</tt> and <tt class="literal">numcols</tt>.
These are global variables, so they are accessible by the rest of
the code inside our (eventual) script. In particular, we need them
in our second pass through the filenames. The code for this resembles
the code to our original solution; all we need to do is
replace the fixed column width and number of columns with the variables:
</p>

<p>
<blockquote><pre class="code">
set -A filenames $(ls "$@")
typeset -L$width fname
let count=0

while (( $count &lt; ${#filenames[*]} )); do
    fname=${filenames[$count]}
    print "$fname  \c"
    let count++
    if [[ $((count % numcols)) == 0 ]]; then
         print          # output a newline
    fi
done

if (( count % numcols != 0 )); then
    print
fi
</pre></blockquote>
</p>

<p>
The entire script consists of both pieces of code.
As yet another "exercise for the reader," consider how you might
rearrange the code to only invoke the <em class="emphasis">ls</em> command once.
(Hint: use at least one arithmetic <tt class="literal">for</tt> loop.)
<a name="IXTR3-310" />
</p>
</div>


<a name="korn2-CHP-7-SECT-2.3.4" /><div class="sect3">
<h3 class="sect3">7.2.3.4. Reading user input</h3>

<p>
<a name="korn2-IDXTERM-1478" />
The other type of task to which <em class="emphasis">read</em> is suited is
prompting a user for input. Think about it: we have hardly
seen any such scripts so far in this book.

In fact, the only
ones were the modified solutions to <a href="ch05_03.htm#korn2-CHP-5-SIDEBAR-5">Task 5-4</a>, which involved
<tt class="literal">select</tt>.
</p>

<?troff .Nd 10?>

<p>
As you've probably figured out, <em class="emphasis">read</em> can be used to get
user input into shell variables.

We can use <em class="emphasis">print</em> to prompt the user, like this:
</p>

<p>
<blockquote><pre class="code">
print -n 'terminal? '
read TERM
print "TERM is $TERM"
</pre></blockquote>
</p>

<p>
Here is what this looks like when it runs:
</p>

<p>
<blockquote><pre class="code">
terminal? <tt class="userinput"><b>vt99</b></tt>
TERM is vt99
</pre></blockquote>
</p>

<p>
<a name="IXT-7-287932" />
<a name="IXT-7-287933" />
However, in order that prompts don't get lost down a pipeline,
shell convention dictates that prompts should go
to standard error, not standard output.
(Recall that <tt class="literal">select</tt> prompts to standard error.)
We could just use file descriptor 2 with the output
redirector we saw earlier in this chapter:
</p>

<p>
<blockquote><pre class="code">
print -n 'terminal? ' &gt;&amp;2
read TERM
print TERM is $TERM
</pre></blockquote>
</p>

<p>
The shell provides a better way of doing the same thing:

<a name="IXT-7-287934" />

if you follow the first variable name
in a <em class="emphasis">read</em> statement with a question mark (<tt class="literal">?</tt>) and a string,
the shell uses that string as a prompt to standard error. In other words:
</p>

<p>
<blockquote><pre class="code">
read TERM?'terminal? '
print "TERM is $TERM"
</pre></blockquote>
</p>

<p>
does the same as the above.
The shell's way is better for the following reasons.
First, this looks a bit nicer;
second, the shell knows not to generate the prompt if the input
is redirected to come from a file; and finally, this scheme allows
you to use vi- or emacs-mode on your input line.
</p>

<p>
We'll flesh out this simple example by showing how <a href="ch05_03.htm#korn2-CHP-5-SIDEBAR-5">Task 5-4</a> would be done if <tt class="literal">select</tt> didn't exist. Compare this with
the code in <a href="ch06_01.htm">Chapter 6</a>:
</p>

<p>
<blockquote><pre class="code">
set -A termnames gl35a t2000 s531 vt99
print 'Select your terminal type:'
while true;  do
    {
        print '1) gl35a'
        print '2) t2000'
        print '3) s531'
        print '4) vt99'
    } &gt;&amp;2
    read REPLY?'terminal? '

    if (( REPLY &gt;= 1 &amp;&amp; REPLY &lt;= 4 )); then
        TERM=${termnames[REPLY-1]}
        print "TERM is $TERM"
        export TERM
        break
    fi
done
</pre></blockquote>
</p>

<p>
The <tt class="literal">while</tt> loop is necessary so that the code repeats if
the user makes an invalid choice.
<a name="IXTR3-311" />
</p>

<p>
This is roughly twice as many lines of code as the first solution in
<a href="ch05_01.htm">Chapter 5</a> -- but exactly as many as the later, more user-friendly version!
This shows that <tt class="literal">select</tt> saves you
code only if you don't mind using the same strings to display
your menu choices as you use inside your script.
</p>

<p>
However, <tt class="literal">select</tt> has other advantages, including the ability
to construct multicolumn menus if there are many choices,
and better handling of empty user input.
</p>
</div>


<a name="korn2-CHP-7-SECT-2.3.5" /><div class="sect3">
<h3 class="sect3">7.2.3.5. Options to read</h3>

<p>
<a name="IXT-7-287935" />
<em class="emphasis">read</em> takes a set of options that are similar to those
for <em class="emphasis">print</em>.
<a href="ch07_02.htm#korn2-CHP-7-TABLE-7">Table 7-7</a>
lists them.

<a name="korn2-IDXTERM-1484" />
<a name="IXT-7-287936" />
 <a name="IXT-7-287937" />
<a name="IXT-7-287938" />
<a name="IXT-7-287939" />
<a name="IXT-7-287940" />
<a name="IXT-7-287941" />
<a name="IXT-7-287942" />

</p>

<a name="korn2-CHP-7-TABLE-7" /><h4 class="objtitle">Table 7-7. read options</h4><table border="1" cellpadding="3">



<tr>
<th>Option</th>
<th>Function</th>
</tr>





<tr>
<td><tt class="literal">-A</tt></td>
<td><p>
Read words into indexed array, starting at index 0.
Unsets all elements of the array first.
</p></td>
</tr>

<tr>
<td><tt class="literal">-d</tt> <em class="replaceable"><tt>delimiter</tt></em></td>
<td><p>
Read up to character <em class="emphasis">delimiter</em>, instead of the
default character, which is a newline.
</p></td>
</tr>

<tr>
<td><tt class="literal">-n</tt> <em class="replaceable"><tt>count</tt></em></td>
<td><p>
Read at most <em class="emphasis">count</em> bytes.<a href="#FOOTNOTE-100">[100]</a>
</p></td>
</tr>

<tr>
<td><tt class="literal">-p</tt></td>
<td>Read from pipe to coroutine; see <a href="ch08_01.htm">Chapter 8</a>.</td>
</tr>

<tr>
<td><tt class="literal">-r</tt></td>
<td><p>
Raw; do not use <tt class="literal">\</tt> as
line continuation character.
</p></td>
</tr>

<tr>
<td><tt class="literal">-s</tt></td>
<td><p>
Save input in command history file; see
<a href="ch01_01.htm">Chapter 1</a>.
</p></td>
</tr>

<tr>
<td><tt class="literal">-t</tt> <em class="replaceable"><tt>nseconds</tt></em></td>
<td><p>
Wait up to <em class="emphasis">nseconds</em> seconds for the input to come in.
If <em class="emphasis">nseconds</em> elapses, return a failure exit status.
</p></td>
</tr>

<tr>
<td><tt class="literal">-u</tt><em class="replaceable"><tt>n</tt></em></td>
<td>Read from file descriptor <em class="emphasis">n</em>.</td>
</tr>


</table><p>
<a name="FOOTNOTE-100" /><p> [100]
This option was added in <em class="emphasis">ksh93e</em>.
</p>
</blockquote>

<p>
Having to type <tt class="literal">read word[0] word[1] word[2]</tt> ... to read
words into an array is painful. It is also error-prone; if the user types more words than
you've provided array variables, the remaining words are all assigned to the last array
variable.  The <em class="emphasis">-A</em> option gets around this, reading each word
one at a time into the corresponding entries in the named array.
</p>

<p>
The <em class="emphasis">-d</em> option lets you read up to some other character
than a newline.  In practical terms, you will probably never need to do this, but
the shell wants to make it possible for you to do it in case you ever need to.
</p>

<p>
Similarly, the <em class="emphasis">-n</em> option frees you from the
default line-oriented way that <em class="emphasis">read</em> consumes input;
it allows you to read a fixed number of bytes.  This is very useful if
you're processing legacy fixed-width data, although this is not
very common on Unix systems.
</p>

<p>

<a name="IXTR3-312" />

<em class="emphasis">read</em> lets you input lines that are longer than the width of
your display device by providing backslash (\) as a continuation
character, just as in shell scripts. The <em class="emphasis">-r</em> option to <em class="emphasis">read</em>
overrides this, in case your script reads from a file that may
contain lines that happen to end in backslashes.
</p>

<p>
<tt class="literal">read -r</tt> also preserves any other escape sequences
the input might contain. For example, if the file <em class="emphasis">fred</em>
contains this line:
</p>

<p>
<blockquote><pre class="code">
A line with a\n escape sequence
</pre></blockquote>
</p>

<p>
<tt class="literal">read -r fredline</tt> will include the backslash in the
variable <tt class="literal">fredline</tt>,
whereas without the <em class="emphasis">-r</em>, <em class="emphasis">read</em>
will "eat" the backslash. As a result:
</p>

<p>
<blockquote><pre class="code">
$ <tt class="userinput"><b>read -r fredline &lt; fred</b></tt>
$ <tt class="userinput"><b>print "$fredline"</b></tt>
A line with a
 escape sequence
$
</pre></blockquote>
</p>

<p>
(Here, <em class="emphasis">print</em> interpreted the <tt class="literal">\n</tt>
escape sequence and turned it into a newline.)
However:
</p>

<p>
<blockquote><pre class="code">
$ <tt class="userinput"><b>read fredline &lt; fred</b></tt>
$ <tt class="userinput"><b>print "$fredline"</b></tt>
A line with an escape sequence
$
</pre></blockquote>
</p>

<p>
<a name="IXTR3-313" />

</p>

<p>

The <em class="emphasis">-s</em> option helps you if you are writing a highly interactive
script and you want to provide the same command-history
capability as the shell itself has.

For example, say you are
writing a new version of <em class="emphasis">mail</em> as a shell script. Your
basic command loop might look like this:
</p>

<p>
<blockquote><pre class="code">
while read -s cmd; do
    # process the command
done
</pre></blockquote>
</p>

<p>
Using <tt class="literal">read -s</tt> allows the user to retrieve
previous commands to your program with the emacs-mode
CTRL-P command or the vi-mode ESC k command.
The <em class="emphasis">kshdb</em> debugger in <a href="ch09_01.htm">Chapter 9</a>
uses this feature.

</p>

<p>
The <em class="emphasis">-t</em> option is quite useful.  It allows you to recover
in case your user has "gone out to lunch," but your script has better things
to do than just wait around for input.  You tell it how many seconds you're willing to
wait before deciding that the user just doesn't care anymore:
</p>

<blockquote><pre class="code">
print -n "OK, Mr. $prisoner, enter your name, rank and serial number: "
# wait two hours, no more
if read -t $((60 * 60 * 2)) name rank serial
then
    # process information
    ...
else
    # prisoner is being silent
    print 'The silent treatment, eh? Just you wait.'
    call_evil_colonel -p $prisoner
    ...
fi
</pre></blockquote>

<p>
If the user enters data before the timeout expires, <em class="emphasis">read</em> returns
0 (success), and the <tt class="literal">then</tt> part of the <tt class="literal">if</tt> is
processed.
On the other hand, when the user enters nothing, the timeout expires and
<em class="emphasis">read</em> returns 1 (failure), executing the <tt class="literal">else</tt>
part of the statement.
</p>

<p>

<a name="IXT-7-287943" />

Although not an option to the <em class="emphasis">read</em> command, the <tt class="literal">TMOUT</tt>
variable can affect it.  Just as for <tt class="literal">select</tt>, if <tt class="literal">TMOUT</tt>
is set to a number representing some number of seconds, the <em class="emphasis">read</em> command
times out if nothing is entered within that time, and returns a failure exit status.
The <em class="emphasis">-t</em> option overrides the setting of <tt class="literal">TMOUT</tt>.
</p>

<p>
<a name="korn2-IDXTERM-1495" />
<a name="korn2-IDXTERM-1496" />

Finally, the <tt class="literal">-u</tt><em class="replaceable"><tt>n</tt></em> option is useful in scripts that
read from more than one file at the same time.
</p>


<p>
<a href="ch07_02.htm#korn2-CHP-7-SIDEBAR-4">Task 7-4</a>
is an example of this that also uses
the <em class="emphasis">n</em><tt class="literal">&lt;</tt>
I/O redirector that we saw earlier in this chapter.
</p>

<a name="korn2-CHP-7-SIDEBAR-4" /><blockquote><table border="1" cellpadding="6"><tr><td>
<h4 class="objtitle">Task 7-4</h4>

<p>
<a name="IXT-7-287944" />

Write a script that prints the contents of two files
side by side.
</p>

</td></tr></table><p></blockquote>
<p>
We'll format the output so the two output columns
are fixed at 30 characters wide.
Here is the code:
</p>

<p>
<blockquote><pre class="code">
typeset -L30 f1 f2
while read -u3 f1 &amp;&amp; read -u4 f2; do
    print "$f1$f2"
done 3&lt;$1 4&lt;$2
</pre></blockquote>
</p>

<p>
<tt class="literal">read -u3</tt> reads from file descriptor 3, and <tt class="literal">3&lt;$1</tt>
directs the file given as first argument to be input on
that file descriptor; the same is true for the second argument
and file descriptor 4.
<a name="IXTR3-314" />
<a name="IXTR3-315" />
Remember that file descriptors 0, 1, and 2 are already used
for standard I/O. We use file descriptors 3 and 4 for
our two input files; it's best to start from 3 and work
upwards to the shell's limit, which is 9.
</p>

<p>
<a name="IXT-7-287945" />

The <em class="emphasis">typeset</em> command and the quotes around the argument
to <em class="emphasis">print</em> ensure that the output columns are 30 characters
wide and that trailing whitespace in the lines from the file is
preserved.
The <tt class="literal">while</tt> loop reads one line from each
file until at least one of them runs out of input.
</p>

<p>
Assume the file <em class="emphasis">dave</em> contains the following:
</p>

<p>
<blockquote><pre class="code">
DAVE
Height: 177.8 cm.
Weight: 79.5 kg.
Hair: brown
Eyes: brown
</pre></blockquote>
</p>

<p>
And the file <em class="emphasis">shirley</em> contains this:
</p>

<p>
<blockquote><pre class="code">
SHIRLEY
Height: 167.6 cm.
Weight: 65.5 kg.
Hair: blonde
Eyes: blue
</pre></blockquote>
</p>

<p>
If the script is called <em class="emphasis">twocols</em>, then <tt class="literal">twocols dave shirley</tt>
produces this output:
</p>

<p>
<blockquote><pre class="code">
DAVE                          SHIRLEY
Height: 177.8 cm.             Height: 167.6 cm.
Weight: 79.5 kg.              Weight: 65.5 kg.
Hair: brown                   Hair: blonde
Eyes: brown                   Eyes: blue
</pre></blockquote>
</p>

<p>
<a name="IXTR3-316" />
<a name="IXTR3-317" />

</p>
</div>
</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch07_01.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch07_03.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">7. Input/Output and Command-Line Processing</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">7.3. Command-Line Processing</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2003</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="1,0,88,96" href="../index.htm"><area shape="rect" coords="90,0,165,96" href="../upt/index.htm"><area shape="rect" coords="168,1,253,107" href="../mac/index.htm"><area shape="rect" coords="255,0,335,97" href="../korn/index.htm"><area shape="rect" coords="337,0,415,109" href="../unixnut/index.htm"><area shape="rect" coords="417,0,512,122" href="../sedawk/index.htm"><area shape="rect" coords="514,0,605,105" href="../lunix/index.htm"><area shape="rect" coords="611,2,694,121" href="../vi/index.htm">
</map>

</body></html>