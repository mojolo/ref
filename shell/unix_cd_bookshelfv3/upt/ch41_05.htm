<html><head><title>Perl Boot Camp, Part 2: Variables and Data Types (Unix Power Tools, 3rd Edition)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Shelley Powers, Jerry Peek, Tim O'Reilly, Mike Loukides and  " /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0-596-00330-7" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="UNIX Power Tools, 3rd Edition" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">

<img src="gifs/smbanner.gif" usemap="#banner-map" border="0" alt="Unix Power Tools" /><map name="banner-map"><area shape="rect" coords="1,-2,616,66" href="index.htm" alt="Unix Power Tools" /><area shape="rect" coords="629,-11,726,25" href="jobjects/fsearch.htm" alt="Search this book" /></map>

<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch41_04.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch41_06.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">41.5. Perl Boot Camp, Part 2: Variables and Data Types</h2>

<p><a name="upt3-IDXTERM-6654" /> <a name="upt3-IDXTERM-6655" /> <a name="upt3-IDXTERM-6656" />Data
types are the kinds of values Perl supports. Common data types
include arbitrarily long
<a name="IXT-41-2523" /><a name="IXT-41-2524" /><a name="IXT-41-2525" />strings (e.g., <tt class="literal">"hi,
bob"</tt>), intergers (e.g., <tt class="literal">42</tt>) and floating
point numbers (e.g., <tt class="literal">3.14</tt>). Perl is a
<em class="emphasis">loosely typed</em><a name="IXT-41-2526" /> <a name="IXT-41-2527" />
language, which means that Perl works hard to let you forget about
what kind of data you're dealing with. For the most
part, you will be dealing with strings, which plays to
Perl's strengths. To manipulate data, variables are
employed. <a href="ch41_05.htm#upt3-CHP-41-TABLE-1">Table 41-1</a> lists the most common variable
types in Perl. For the full story on Perl data types, read the
<em class="filename">perldata</em> manpage.
</p>

<a name="upt3-CHP-41-TABLE-1" /><h4 class="objtitle">Table 41-1. Common Perl variables </h4><table border="1" cellpadding="3">




<tr>
<th>
<p>Name</p>
</th>
<th>
<p>Example</p>
</th>
<th>
<p>Description</p>
</th>
</tr>


<tr>
<td>
<p><tt class="literal">scalar</tt></p>
</td>
<td>
<p><tt class="literal">$lastname</tt>, <tt class="literal">$PI</tt></p>
</td>
<td>
<p>Holds single values</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">array</tt></p>
</td>
<td>
<p><tt class="literal">@people</tt>, <tt class="literal">$peple[0]</tt></p>
</td>
<td>
<p>Holds an ordered sequence of scalar values</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">hash</tt></p>
</td>
<td>
<p><tt class="literal">%cgi_params</tt>,
<tt class="literal">$cgi_params{'action'}</tt>
</p>
</td>
<td>
<p>Holds a set of key-value pairs</p>
</td>
</tr>

</table><p>

<a name="upt3-CHP-41-SECT-5.1" /><div class="sect2">
<h3 class="sect2">41.5.1. Scalars</h3>

<p><a name="upt3-IDXTERM-6664" /> <a name="upt3-IDXTERM-6665" />
<a name="upt3-IDXTERM-6666" />When
you want to store single values, like any of those given in the
previous paragraph, you will use a <tt class="literal">scalar</tt>
variable. Scalars are labeled with a <tt class="literal">$</tt> followed by
a letter and any sequence of letters, numbers, and underscores.
<a name="IXT-41-2530" />Scalars defined at the top of scripts
are often used as <a name="IXT-41-2531" />constants. You may need to tweak
some of them, particularly those containing filesystem paths, to get
third-party scripts to run on your system.
</p>

<p>Of course, values can be compared to each other or added together.
Perl has <a name="IXT-41-2532" /><a name="IXT-41-2533" /><a name="IXT-41-2534" />relational operators that treat
values as numbers and other relational operators that treat values as
strings. Although Perl has different operators for numbers and
strings, Perl makes scalar values do the right thing most of the
time. For example, you want to create a series of filenames like
<em class="emphasis">mail_num</em>. The following code does this.
</p>

<blockquote><pre class="code">foreach my $num (1..10) {
   print "mail_" . $num . "\n";
}</pre></blockquote>

<p>Even though <tt class="literal">$num</tt> is a number, the string
concatenation operator is able to use it as a string. <a href="ch40_07.htm#upt3-CHP-40-TABLE-2">Table 40-2</a> shows string operators, and <a href="ch41_05.htm#upt3-CHP-41-TABLE-3">Table 41-3</a> shows the numerical ones. See the
<tt class="literal">perlop</tt> manpage for the full story.
</p>

<a name="upt3-CHP-41-TABLE-2" /><h4 class="objtitle">Table 41-2. String operators </h4><table border="1" cellpadding="3">




<tr>
<th>
<p>Operator</p>
</th>
<th>
<p>Example</p>
</th>
<th>
<p>Description</p>
</th>
</tr>


<tr>
<td>
<p><tt class="literal">.</tt><a name="IXT-41-2538" /><a name="IXT-41-2539" /> <a name="IXT-41-2540" />
</p>
</td>
<td>
<p><tt class="literal">$saluation . " Jones"</tt></p>
</td>
<td>
<p>String concatenation</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">eq</tt><a name="IXT-41-2541" />
</p>
</td>
<td>
<p><tt class="literal">$foo eq $bar</tt></p>
</td>
<td>
<p>String equality test</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">ne</tt><a name="IXT-41-2542" /><a name="IXT-41-2543" /><a name="IXT-41-2544" />
</p>
</td>
<td>
<p><tt class="literal">$bar ne $baz</tt></p>
</td>
<td>
<p>String inequality test</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">gt</tt><a name="IXT-41-2545" />
</p>
</td>
<td>
<p><tt class="literal">$name gt "Bob"</tt></p>
</td>
<td>
<p>True if left string comes after right in ASCII</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">lt</tt><a name="IXT-41-2546" />
</p>
</td>
<td>
<p><tt class="literal">$name lt "Xavier"</tt></p>
</td>
<td>
<p>True if left string comes before right in ASCII</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">cmp</tt><a name="IXT-41-2547" />
</p>
</td>
<td>
<p><tt class="literal">$name cmp "Wilson"</tt></p>
</td>
<td>
<p>Return -1 if left operand ASCII-sorts before the right; 0 if right
and left are equal; 1 if right sorts before left
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">lc</tt><a name="IXT-41-2548" /><a name="IXT-41-2549" />
</p>
</td>
<td>
<p><tt class="literal">lc "Bob"</tt></p>
</td>
<td>
<p>Return an all-lowercase copy of the given string</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">uc</tt><a name="IXT-41-2550" /><a name="IXT-41-2551" />
</p>
</td>
<td>
<p><tt class="literal">uc "lorrie"</tt></p>
</td>
<td>
<p>Return an all-uppercase copy of the given string</p>
</td>
</tr>

</table><p>

<a name="upt3-CHP-41-TABLE-3" /><h4 class="objtitle">Table 41-3. Numerical operators </h4><table border="1" cellpadding="3">




<tr>
<th>
<p>Operator</p>
</th>
<th>
<p>Example</p>
</th>
<th>
<p>Description</p>
</th>
</tr>


<tr>
<td>
<p><tt class="literal">+</tt><a name="IXT-41-2555" />
</p>
</td>
<td>
<p><tt class="literal">$a + 1</tt></p>
</td>
<td>
<p>Numerical addition</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">-</tt><a name="IXT-41-2556" /> <a name="IXT-41-2557" />
</p>
</td>
<td>
<p><tt class="literal">$c - 2</tt></p>
</td>
<td>
<p>Numerical subtraction</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">*</tt><a name="IXT-41-2558" />
</p>
</td>
<td>
<p><tt class="literal">3 * $b</tt></p>
</td>
<td>
<p>Numerical multiplication</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">/</tt><a name="IXT-41-2559" />
</p>
</td>
<td>
<p><tt class="literal">4/$non_zero</tt></p>
</td>
<td>
<p>Numerical division</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">++</tt><a name="IXT-41-2560" /> <a name="IXT-41-2561" />
</p>
</td>
<td>
<p><tt class="literal">$a++</tt></p>
</td>
<td>
<p>Autoincrement; adds one to a number</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">==</tt><a name="IXT-41-2562" />
</p>
</td>
<td>
<p><tt class="literal">$a == $b</tt></p>
</td>
<td>
<p>Numeric equality test</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">!=</tt><a name="IXT-41-2563" /><a name="IXT-41-2564" /> <a name="IXT-41-2565" />
</p>
</td>
<td>
<p><tt class="literal">$p != $q</tt></p>
</td>
<td>
<p>Numeric inequality test</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">&lt;</tt><a name="IXT-41-2566" /> <a name="IXT-41-2567" /> <a name="IXT-41-2568" /><a name="IXT-41-2569" />
</p>
</td>
<td>
<p><tt class="literal">$diff &lt; 32</tt></p>
</td>
<td>
<p>Numeric less-than test </p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">&gt;</tt></p>
</td>
<td>
<p><tt class="literal">$sum &gt; 64</tt></p>
</td>
<td>
<p>Numeric greater-than test</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">&lt;=&gt;</tt><a name="IXT-41-2570" />
</p>
</td>
<td>
<p><tt class="literal">$sum &lt;=&gt; 64</tt></p>
</td>
<td>
<p>Return -1 if left is numerically less than right; 0 if left equals
right; 1 if right is less than left
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">&lt;=</tt><a name="IXT-41-2571" /><a name="IXT-41-2572" />
</p>
</td>
<td>
<p><tt class="literal">$sum &lt;= 64</tt></p>
</td>
<td>
<p>True if left operand is numerically less than or equal to right</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">&gt;=</tt><a name="IXT-41-2573" /><a name="IXT-41-2574" />
</p>
</td>
<td>
<p><tt class="literal">$sum &gt;= 64</tt></p>
</td>
<td>
<p>True if left is numerally greater than or equal to right</p>
</td>
</tr>

</table><p>

<p>You may have notice that some of the operators in the previous tables
were described as returning <a name="IXT-41-2575" /> <a name="IXT-41-2576" />true or false values. A true value in Perl
is any value that isn't false, and there are only 4
kinds of false values in Perl:
</p>

<ul><li>
<p>values that are numerically zero</p>
</li><li>
<p>values that are empty strings</p>
</li><li>
<p>values that are <tt class="literal">undef</tt></p>
</li><li>
<p>empty lists</p>
</li></ul>
<p>Like many other languages, Perl supports <a name="IXT-41-2577" /><a name="IXT-41-2578" /><a name="IXT-41-2579" />Boolean operators (see <a href="ch41_05.htm#upt3-CHP-41-TABLE-3">Table 41-3</a>) that return true or false values. Typically,
you encounter these in <tt class="literal">if</tt> statements like the
following:
</p>

<blockquote><pre class="code">if ($temp &lt; 30 &amp;&amp; $is_rainy) {
  print "I'm telecommuting today\n";
}</pre></blockquote>

<p>Another common use of Boolean operators is to short-circuit two
expressions. This is a way to prevent the right operand from
executing unless the left operand returns a desired truth value.
Consider the very ordinary case of opening a filehandle for reading.
A common idiom to do this is:
</p>

<blockquote><pre class="code">open (FH, "<em class="replaceable"><tt>filename</tt></em>") || die "Can't open file";</pre></blockquote>

<p>This short-cut operation depends on the <tt class="literal">open</tt>
function returning a true value if it can open the requested file.
Only if it cannot is the right side of the <tt class="literal">||</tt>
operator executed (<tt class="literal">die</tt> prints whatever message you
provide and halts the program).
</p>

<a name="upt3-CHP-41-TABLE-4" /><h4 class="objtitle">Table 41-4. Boolean operators </h4><table border="1" cellpadding="3">




<tr>
<th>
<p>Operator</p>
</th>
<th>
<p>Example</p>
</th>
<th>
<p>Description</p>
</th>
</tr>


<tr>
<td>
<p><tt class="literal">&amp;&amp;</tt><a name="IXT-41-2580" />
</p>
</td>
<td>
<p><tt class="literal">$a &amp;&amp; $b</tt></p>
</td>
<td>
<p>True if both $a and $b are true</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">||</tt><a name="IXT-41-2581" />
</p>
</td>
<td>
<p><tt class="literal">$a || $b</tt></p>
</td>
<td>
<p>True if either $a or $b is true</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">!</tt></p>
</td>
<td>
<p><tt class="literal">!$a</tt></p>
</td>
<td>
<p>True if $a is false</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">and</tt><a name="IXT-41-2582" />
</p>
</td>
<td>
<p><tt class="literal">$a and $b</tt></p>
</td>
<td>
<p>Same as &amp;&amp;, but with a lower precedence</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">or</tt><a name="IXT-41-2583" />
</p>
</td>
<td>
<p><tt class="literal">$a or $b</tt></p>
</td>
<td>
<p>Same as ||, but with a lower precedence</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">not</tt><a name="IXT-41-2584" /> <a name="IXT-41-2585" />
</p>
</td>
<td>
<p><tt class="literal">not $a</tt></p>
</td>
<td>
<p>Same as !, but with a lower precedence</p>
</td>
</tr>

</table><p>

<p><a name="IXT-41-2586" /><a name="IXT-41-2587" />Looking at <a href="ch41_05.htm#upt3-CHP-41-TABLE-4">Table 41-4</a>,
you will notice that there appear to be redundant operators. The
operators that are English words have a lower precedence that the
symbolic ones. Precedence is simply the order in which Perl executes
<a name="IXT-41-2588" />expressions. You are
probably familiar with precedence rules from mathematics:
</p>

<blockquote><pre class="code">1 + 2 * 3 + 4 = 11
(1 + 2) * (3 + 4) = 21</pre></blockquote>

<p>Similarly, Perl's operators have precedence as well,
as shown in <a href="ch41_05.htm#upt3-CHP-41-EX-2">Example 41-2</a>.
</p>

<a name="upt3-CHP-41-EX-2" /><div class="example">
<h4 class="objtitle">Example 41-2. Precedence</h4>
<blockquote><pre class="code">lc $a || "BB"   # like (lc $a) || ("BB")
lc ($a || "BB")</pre></blockquote>
</div>

<p>Because <tt class="literal">||</tt> has a lower precedence that the
<tt class="literal">lc</tt> operator, the first line of <a href="ch41_05.htm#upt3-CHP-41-EX-2">Example 41-2</a> is a Boolean test between two expressions. In
the second line, the Boolean <tt class="literal">||</tt> operator is used
to create a default argument to <tt class="literal">lc</tt> should
<tt class="literal">$a</tt> be a false value.
</p>

<p><a name="IXT-41-2589" />Because Perl
doesn't require parentheses around built-in
operators and functions, you will often see code like:
</p>

<blockquote><pre class="code">open FH, "&gt; " . "<em class="replaceable"><tt>filename</tt></em>" or die "Can't open file";
print FH "[info]: disk write error\n";</pre></blockquote>

<p>Precedence ambiguities can be resolved by using parentheses where
doubt occurs.
</p>

<p>Although Perl has many special variables, the one
you'll encounter most is
<tt class="literal">$_</tt><a name="IXT-41-2590" />. Many operators and functions, such as
<tt class="literal">lc</tt> and
<tt class="literal">print</tt><a name="IXT-41-2591" /><a name="IXT-41-2592" />,
will operate on <tt class="literal">$_</tt> in the absence of an explicit
parameter, as in <a href="ch41_05.htm#upt3-CHP-41-EX-3">Example 41-3</a>.
</p>

<a name="upt3-CHP-41-EX-3" /><div class="example">
<h4 class="objtitle">Example 41-3. Simple echo loop </h4>
<blockquote><pre class="code">while(&lt;&gt;){
   print
}</pre></blockquote>
</div>

<p>In this example, every line read from standard input with the
<tt class="literal">&lt;&gt;</tt> operator is available inside the
<b class="emphasis-bold">while</b> (<a href="ch41_07.htm#upt3-CHP-41-SECT-7">Section 41.7</a>)
loop through <tt class="literal">$_</tt>. The <tt class="literal">print</tt>
function, in the absence of an explicit argument, echoes the value of
<tt class="literal">$_</tt>. Note that <tt class="literal">$_</tt> can be
assigned to (e.g., <tt class="literal">$_ = "Hello,
Perl</tt>") just like any other
scalar.<a name="IXTR3-2688" />
<a name="IXTR3-2689" />
<a name="IXTR3-2690" />
</p>

</div>
<a name="upt3-CHP-41-SECT-5.2" /><div class="sect2">
<h3 class="sect2">41.5.2. Arrays</h3>

<p><a name="IXT-41-2593" /><a name="IXT-41-2594" />When
you want to collect more than one value into a variable, you have two
ways to go in Perl. If you need an ordered set of values, you will
choose to use a Perl array. These variables start with
<tt class="literal">@</tt><a name="IXT-41-2595" /> and
are followed by a label that follows the same convention as a scalar.
Two global arrays have already been mentioned:
<tt class="literal">@INC</tt> and <tt class="literal">@ARGV</tt>. Since arrays
hold multiple values, getting and setting values is a little
different from scalars. Here's an example of
creating an array with values, looking at one, and assigning a new
value to that array index.
</p>

<blockquote><pre class="code">@things    = ('phone', 'cat', 'hard drive');
print "The second element is: ", $things[1], "\n";

$things[1] = 'dog';
print "The second element is now: ", $things[1], "\n";</pre></blockquote>

<p>In the first line, the array <tt class="literal">@things</tt> is
initialized with a list of three scalar values. Array indexes begin
with zero, so the second element is accessed through the index value
of 1. Arrays will grow as needed, so you could have added a fourth
element like this:
</p>

<blockquote><pre class="code">$things[3] = 'DVD player';</pre></blockquote>

<p>Why is a <tt class="literal">$</tt> used here and not <tt class="literal">@</tt>?
Use <tt class="literal">@</tt> only when referring to the whole array
variable. Each element is a scalar whose name is
<tt class="literal">$things[</tt><em class="replaceable"><tt>index</tt></em>]. This
rule comes up again when dealing with hashes.
</p>

<p><a name="IXT-41-2596" /><a name="IXT-41-2597" />Typically you will want to iterate
through all the values in an array, which is done with <b class="emphasis-bold">loops</b>
(<a name="IXT-41-2598" /><a name="IXT-41-2599" /><a href="ch41_07.htm#upt3-CHP-41-SECT-7">Section 41.7</a>). Although
there are several looping constructs, the most common idiom to
examine all the values in an array sequentially is shown in <a href="ch41_05.htm#upt3-CHP-41-EX-4">Example 41-4</a>. 
</p>

<a name="upt3-CHP-41-EX-4" /><div class="example">
<h4 class="objtitle">Example 41-4. Using foreach to loop through an array </h4>
<blockquote><pre class="code">print "Paths Perl checks for modules\n";
foreach my $el (@INC) {
  print $el, "\n";
}</pre></blockquote>
</div>

<p><a name="IXT-41-2600" /><a name="IXT-41-2601" /><a name="IXT-41-2602" />Lists are a data type that is closely
related to arrays. Lists are sequences of scalar values enclosed in
parentheses that are not associated with an array variable. They are
used to initialize a new array variable. Common
<a name="IXT-41-2603" /><a name="IXT-41-2604" />array
operators are listed in <a href="ch41_05.htm#upt3-CHP-41-TABLE-5">Table 41-5</a>.
</p>

<blockquote><pre class="code">my @primes     = (1,3,5,7,9,11);
my @empty_list = ( );</pre></blockquote>

<a name="upt3-CHP-41-TABLE-5" /><h4 class="objtitle">Table 41-5. Common array operators </h4><table border="1" cellpadding="3">




<tr>
<th>
<p>Name</p>
</th>
<th>
<p>Example</p>
</th>
<th>
<p>Description</p>
</th>
</tr>


<tr>
<td>
<p><tt class="literal">pop</tt><a name="IXT-41-2605" />
</p>
</td>
<td>
<p><tt class="literal">$last = pop @array;</tt></p>
</td>
<td>
<p>Return last element of array; remove that element from array</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">push</tt><a name="IXT-41-2606" />
</p>
</td>
<td>
<p><tt class="literal">push @array,
@</tt><em class="replaceable"><tt>new_elements</tt></em><tt class="literal">;</tt>
</p>
</td>
<td>
<p>Add the contents of @<em class="replaceable"><tt>new_elements</tt></em> to the
end of target array
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">shift</tt><a name="IXT-41-2607" />
</p>
</td>
<td>
<p><tt class="literal">$first = shift @array;</tt></p>
</td>
<td>
<p>Return the first element of array; shift all elements one index lower
(removing the first element)
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">unshift</tt><a name="IXT-41-2608" />
</p>
</td>
<td>
<p><tt class="literal">unshift @array,
@</tt><em class="replaceable"><tt>new_elements</tt></em><tt class="literal">;</tt>
</p>
</td>
<td>
<p>Add @<em class="replaceable"><tt>new_elements</tt></em> to the beginning of
target array
</p>
</td>
</tr>

</table><p>

</div>
<a name="upt3-CHP-41-SECT-5.3" /><div class="sect2">
<h3 class="sect2">41.5.3. Hashes</h3>

<p><a name="IXT-41-2609" />Associative arrays, or
<a name="IXT-41-2610" /><a name="IXT-41-2611" /><a name="IXT-41-2612" />hashes, are
a collection of scalar values that are arranged in
<a name="IXT-41-2613" />key-value pairs. Instead of using
integers to retrieve values in a hash, strings are used. Hashes begin
with <tt class="literal">%</tt>. <a href="ch41_05.htm#upt3-CHP-41-EX-5">Example 41-5</a> shows a hash
variable in action.
</p>

<a name="upt3-CHP-41-EX-5" /><div class="example">
<h4 class="objtitle">Example 41-5. Using hashes </h4>
<blockquote><pre class="code">my %birthdays = (
                 'mom'    =&gt; 'JUN 14',
                 'archie' =&gt; 'JUN 12',
                 'jay'    =&gt; 'JUL 11',
                );

print "Archie's birthday is: ", $birthdays{'archie'}, "\n";
$birthday{'joe'} = 'DEC 12';
print "My birthday is: ", $birthdays{'joe'}, "\n";</pre></blockquote>
</div>

<p>Hashes are a funny kind of list. When initializing a hash with
values, it is common to arrange the list in key-value pairs. The
strange-looking <tt class="literal">=&gt;</tt><a name="IXT-41-2614" /> operator is often called a
<a name="IXT-41-2615" /> <a name="IXT-41-2616" />"fat
comma" because these two lines of Perl do the same
thing:
</p>

<blockquote><pre class="code">%birthdays = ( 'jay' =&gt; 'JUL 11' );
%birthdays = ( 'jay', 'JUL 11');</pre></blockquote>

<p>Use the fat comma when initializing hashes since it conveys the
association between the values better. As an added bonus, the fat
comma makes unquoted barewords on its left into quoted strings.
</p>

<p><a href="ch41_05.htm#upt3-CHP-41-EX-6">Example 41-6</a> shows some quoting styles for hash keys.</p>

<a name="upt3-CHP-41-EX-6" /><div class="example">
<h4 class="objtitle">Example 41-6. Various quoting styles for hash keys </h4>
<blockquote><pre class="code">my %baz = ( foo =&gt; 1,
            'bar', 2,
            'boz' =&gt; 3);</pre></blockquote>
</div>

<p>Unlike arrays, hashes use strings to
<a name="IXT-41-2617" />index
into the list. So to retrieve the birthday of
"jay", put the key inside curly
braces, like this:
</p>

<blockquote><pre class="code">print "Jay's birthday is: ", $birthday{'jay'}, "\n";</pre></blockquote>

<p>Because Perl assumes that <a name="IXT-41-2618" />barewords used as a key when retrieving a
hash value are autoquoted, you may omit quotes between the curly
braces (e.g., <tt class="literal">$birthday{jay}</tt>). Like arrays, hashes
will grow as you need them to. Whenever you need to model a set or
record the number of event occurrences, hashes are the variable to
use.
</p>

<p>Like arrays, you will often need to
<a name="IXT-41-2619" /> <a name="IXT-41-2620" />iterate over the set of key-value pairs
in a hash. Two common techniques for doing this are shown in <a href="ch41_05.htm#upt3-CHP-41-EX-7">Example 41-7</a>. <a href="ch41_05.htm#upt3-CHP-41-TABLE-6">Table 41-6</a> lists common
Perl hash functions.
</p>

<a name="upt3-CHP-41-EX-7" /><div class="example">
<h4 class="objtitle">Example 41-7. Interating over a hash </h4>
<blockquote><pre class="code">my %example = (foo =&gt; 1, bar =&gt; 2, baz =&gt; 3);

while (my ($key, $value) = %example) {
   print "$key has a value of $value\n";
}

foreach my $key (keys %example) {
  print "$key has a value of $example{$key}\n";
}</pre></blockquote>
</div>

<a name="upt3-CHP-41-TABLE-6" /><h4 class="objtitle">Table 41-6. Common Perl hash functions</h4><table border="1" cellpadding="3">




<tr>
<th>
<p>Name</p>
</th>
<th>
<p>Example</p>
</th>
<th>
<p>Description</p>
</th>
</tr>


<tr>
<td>
<p><tt class="literal">delete</tt><a name="IXT-41-2623" />
</p>
</td>
<td>
<p><tt class="literal">delete
$hash{{</tt><em class="replaceable"><tt>key</tt></em>"}
</p>
</td>
<td>
<p>Delete the key-value pair from hash that is indexed on
<em class="replaceable"><tt>key</tt></em>
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">each</tt><a name="IXT-41-2624" />
</p>
</td>
<td>
<p><tt class="literal">($key, $value) = each %hash</tt></p>
</td>
<td>
<p>Return the next key-value pair in hash; the pairs
aren't usefully ordered
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">exists</tt><a name="IXT-41-2625" />
</p>
</td>
<td>
<p><tt class="literal">print "key found" if exists
$hash{"</tt><em class="replaceable"><tt>key</tt></em>"}
</p>
</td>
<td>
<p>Return true if hash has <em class="replaceable"><tt>key</tt></em>, even if that
key's value if undefined
</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">keys</tt><a name="IXT-41-2626" />
</p>
</td>
<td>
<p><tt class="literal">@keys = keys %hash</tt></p>
</td>
<td>
<p>Return the list of keys in the hash; not ordered</p>
</td>
</tr>
<tr>
<td>
<p><tt class="literal">values</tt><a name="IXT-41-2627" />
</p>
</td>
<td>
<p><tt class="literal">@values = values %hash</tt></p>
</td>
<td>
<p>Return the list of values in the hash; values will be in the same
order as keys fetched by <tt class="literal">keys %hash</tt>
</p>
</td>
</tr>

</table><p>

</div>
<a name="upt3-CHP-41-SECT-5.4" /><div class="sect2">
<h3 class="sect2">41.5.4. References</h3>

<p><a name="IXT-41-2628" /><a name="IXT-41-2629" />As odd
as it may first seem, it is sometimes necessary to have variables for
variables. A funny kind of scalar, a reference is a sort of IOU that
promises where the original variable's data can be
found. References are primarily used in cases. First, because hashes
and arrays store only scalar values, the only way to store one
multivalued data type in another is to store a reference instead (see
the <em class="filename">perldsc</em> manpage for more details). Second,
when the size of a data structure makes a variable inefficient to
pass into subroutines, a reference is passed instead. Third, because
arguments passed into subroutines are really just copies of the
original, there's no way to change the original
values of the arguments back in the calling context. If you give a
subroutine a reference as an argument, it can change that value in
the caller. Consult the <em class="filename">perlref</em> and
<em class="filename">perlreftut</em> manpages for more details on
references.
</p>

<p>Taking a reference to a variable is straightforward. Simply use the
reference operator, <tt class="literal">\</tt>, to create a reference. For
example:
</p>

<blockquote><pre class="code">$scalar_ref = \$bob;
$array_ref  = \@things;
$hash_ref   = \%grades;</pre></blockquote>

<p>You can even create references without variables:</p>

<blockquote><pre class="code">$anonymous_array = [ 'Mojo Jo-Jo', 'Fuzzy Lumpkins', 'Him' ];
$anonymous_hash  = { 'pink'  =&gt; 'Blossom',
                     'green' =&gt; 'Buttercup',
                     'blue'  =&gt; 'Bubbles',
                   };</pre></blockquote>

<p><a name="IXT-41-2630" /><a name="IXT-41-2631" />The square brackets return a reference to
the list that they surround. The curly braces create a reference to a
hash. Arrays and hashes created in this way are called
<em class="emphasis">anonymous</em> because there is no named variable to
which these references refer.
</p>

<p>There are two ways of<a name="IXT-41-2632" /> <a name="IXT-41-2633" />
deferencing references (that is, getting back the original values).
The first way is to use <tt class="literal">{}</tt><a name="IXT-41-2634" />. For instance:
</p>

<blockquote><pre class="code">print "Your name is: ", ${$scalar_ref};

foreach my $el ( @{$anonymous_array} ) {
  print "Villian: $el\n";
}

while (my ($key, $value) = each %{$anonymous_hash}) {
  print "$key is associated with $value\n";
}</pre></blockquote>

<p>The second way, using<a name="IXT-41-2635" /> <tt class="literal">-&gt;</tt>, is useful
only for references to collection types.
</p>

<blockquote><pre class="code">print "$anonymous_hash-&gt;{'pink'} likes the color pink\n"; # 'Blossom'
print "The scariest villian of all is $anonymous_array-&gt;[2]\n"; # 'Him'</pre></blockquote>

<p> <em class="emphasis">-- JJ<a name="IXTR3-2691" /> <a name="IXTR3-2692" /> <a name="IXTR3-2693" /></em> 
</p>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch41_04.htm"><img src="../gifs/txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.htm"><img src="../gifs/txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch41_06.htm"><img src="../gifs/txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">41.4. Perl Boot Camp, Part 1: Typical Script Anatomy</td><td align="center" valign="top" width="228"><a href="index/index.htm"><img src="../gifs/index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">41.6. Perl Boot Camp, Part 3: Branching and Looping</td></tr></table></div>
<hr width="684" align="left" />

<img src="../gifs/navbar.gif" usemap="#library-map" border="0" alt="Library Navigation Links" />
<p><p><font size="-1"><a href="copyrght.htm">Copyright &copy; 2003</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="1,0,88,96" href="../index.htm"><area shape="rect" coords="90,0,165,96" href="../upt/index.htm"><area shape="rect" coords="168,1,253,107" href="../mac/index.htm"><area shape="rect" coords="255,0,335,97" href="../korn/index.htm"><area shape="rect" coords="337,0,415,109" href="../unixnut/index.htm"><area shape="rect" coords="417,0,512,122" href="../sedawk/index.htm"><area shape="rect" coords="514,0,605,105" href="../lunix/index.htm"><area shape="rect" coords="611,2,694,121" href="../vi/index.htm">
</map>

</body></html>